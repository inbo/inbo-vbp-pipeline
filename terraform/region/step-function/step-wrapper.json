{
  "Comment": "Utility wrapper to handle concurrency limits, state tracking and failure",
  "StartAt": "Set Variables",
  "States": {
    "Set Variables": {
      "Type": "Pass",
      "Next": "Catch Errors",
      "Assign": {
        "config": "{% $states.context.Execution.Input.config %}",
        "dataResourceId": "{% $states.input.dataResourceId %}",
        "rootPipelineName": "{% $exists($states.context.Execution.Input.rootPipelineName) ? $states.context.Execution.Input.rootPipelineName : $states.context.Execution.Name %}"
      }
    },
    "Catch Errors": {
      "Type": "Parallel",
      "Next": "Update State and Cleanup Locks",
      "Branches": [
        {
          "StartAt": "Should Limit Concurrency?",
          "States": {
            "Should Limit Concurrency?": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Set State to Queued",
                  "Condition": "{% $exists($states.context.Execution.Input.concurrencyLimit) %}"
                }
              ],
              "Default": "Set State to Running and Lock Data Resource",
              "Output": {
                "comingFromQueued": false
              }
            },
            "Set State to Queued": {
              "Type": "Task",
              "Arguments": {
                "TransactItems": [
                  {
                    "Put": {
                      "TableName": "{% $config.dynamodb_table_name %}",
                      "Item": {
                        "PK": {
                          "S": "{% 'RUN#' & $states.context.Execution.Input.rootPipelineName %}"
                        },
                        "SK": {
                          "S": "{% $join(['DATA_RESOURCE', $uppercase($states.context.Execution.Input.stepName), 'QUEUED', $dataResourceId], '#') %}"
                        },
                        "DataResourceId": {
                          "S": "{%  $dataResourceId %}"
                        },
                        "Step": {
                          "S": "{% $uppercase($states.context.Execution.Input.stepName) %}"
                        },
                        "State": {
                          "S": "QUEUED"
                        },
                        "Timestamp": {
                          "S": "{% $now() %}"
                        },
                        "ExecutionId": {
                          "S": "{% $states.context.Execution.Id %}"
                        }
                      }
                    }
                  },
                  {
                    "Update": {
                      "TableName": "{% $config.dynamodb_table_name %}",
                      "Key": {
                        "PK": {
                          "S": "{% 'RUN#' & $states.context.Execution.Input.rootPipelineName %}"
                        },
                        "SK": {
                          "S": "{% 'STATS#' & $uppercase($states.context.Execution.Input.stepName) %}"
                        }
                      },
                      "UpdateExpression": "ADD #queued :one",
                      "ExpressionAttributeNames": {
                        "#queued": "Queued"
                      },
                      "ExpressionAttributeValues": {
                        ":one": {
                          "N": "1"
                        }
                      }
                    }
                  }
                ]
              },
              "Resource": "arn:aws:states:::aws-sdk:dynamodb:transactWriteItems",
              "Next": "Acquire Concurrency Lock",
              "Retry": [
                {
                  "ErrorEquals": ["DynamoDb.TransactionCanceledException"],
                  "BackoffRate": 2,
                  "IntervalSeconds": 1,
                  "MaxAttempts": 3,
                  "JitterStrategy": "FULL"
                }
              ]
            },
            "Acquire Concurrency Lock": {
              "Type": "Task",
              "Resource": "arn:aws:states:::states:startExecution.sync:2",
              "Arguments": {
                "StateMachineArn": "{% $config.state_machine_lock_arn %}",
                "Input": {
                  "AWS_STEP_FUNCTIONS_STARTED_BY_EXECUTION_ID": "{% $states.context.Execution.Id %}",
                  "dynamodbTableName": "{% $config.dynamodb_table_name %}",
                  "lockQueueUrl": "{% $lookup($config.sqs_lock_queues, $lowercase($states.context.Execution.Input.stepName)) %}",
                  "lockKey": "{% $states.context.Execution.Input.stepName %}",
                  "lockLimit": "{% $states.context.Execution.Input.concurrencyLimit %}",
                  "lockCheckInterval": "{% $config.concurrency_lock_check_interval_s %}",
                  "lockTimeout": "{% $config.concurrency_lock_timeout_ms %}"
                }
              },
              "Next": "Set State to Running and Lock Data Resource",
              "Output": {
                "comingFromQueued": true
              }
            },
            "Set State to Running and Lock Data Resource": {
              "Type": "Task",
              "Arguments": {
                "TransactItems": [
                  {
                    "Delete": {
                      "TableName": "{% $config.dynamodb_table_name %}",
                      "Key": {
                        "PK": {
                          "S": "{% 'RUN#' & $states.context.Execution.Input.rootPipelineName %}"
                        },
                        "SK": {
                          "S": "{% $join(['DATA_RESOURCE', $uppercase($states.context.Execution.Input.stepName), 'QUEUED', $dataResourceId], '#') %}"
                        }
                      }
                    }
                  },
                  {
                    "Put": {
                      "TableName": "{% $config.dynamodb_table_name %}",
                      "Item": {
                        "PK": {
                          "S": "{% 'RUN#' & $states.context.Execution.Input.rootPipelineName %}"
                        },
                        "SK": {
                          "S": "{% $join(['DATA_RESOURCE', $uppercase($states.context.Execution.Input.stepName), 'RUNNING', $dataResourceId], '#') %}"
                        },
                        "DataResourceId": {
                          "S": "{%  $dataResourceId %}"
                        },
                        "Step": {
                          "S": "{% $uppercase($states.context.Execution.Input.stepName) %}"
                        },
                        "State": {
                          "S": "RUNNING"
                        },
                        "Timestamp": {
                          "S": "{% $now() %}"
                        },
                        "ExecutionId": {
                          "S": "{% $states.context.Execution.Id %}"
                        }
                      }
                    }
                  },
                  {
                    "Update": {
                      "TableName": "{% $config.dynamodb_table_name %}",
                      "Key": {
                        "PK": {
                          "S": "{% 'RUN#' & $states.context.Execution.Input.rootPipelineName %}"
                        },
                        "SK": {
                          "S": "{% 'STATS#' & $uppercase($states.context.Execution.Input.stepName) %}"
                        }
                      },
                      "UpdateExpression": "ADD #running :one, #queued :minusOneIfFromQueued",
                      "ExpressionAttributeNames": {
                        "#queued": "Queued",
                        "#running": "Running"
                      },
                      "ExpressionAttributeValues": {
                        ":one": {
                          "N": "1"
                        },
                        ":minusOneIfFromQueued": {
                          "N": "{% $states.input.comingFromQueued ? '-1' : '0' %}"
                        }
                      }
                    }
                  },
                  {
                    "Update": {
                      "TableName": "{% $config.dynamodb_table_name %}",
                      "Key": {
                        "PK": {
                          "S": "{% 'LOCK#' & $dataResourceId %}"
                        },
                        "SK": {
                          "S": "{% 'LOCK#' & $dataResourceId  %}"
                        }
                      },
                      "UpdateExpression": "ADD #executionIds :executionId",
                      "ConditionExpression": "attribute_not_exists(#executionIds) or size(#executionIds) < :lockLimit",
                      "ExpressionAttributeNames": {
                        "#executionIds": "ExecutionIds"
                      },
                      "ExpressionAttributeValues": {
                        ":executionId": {
                          "Ss": ["{% $states.context.Execution.Id %}"]
                        },
                        ":lockLimit": {
                          "N": "1"
                        }
                      }
                    }
                  }
                ]
              },
              "Resource": "arn:aws:states:::aws-sdk:dynamodb:transactWriteItems",
              "Next": "Is individual DataResource?",
              "Retry": [
                {
                  "ErrorEquals": ["DynamoDb.TransactionCanceledException"],
                  "BackoffRate": 2,
                  "IntervalSeconds": 1,
                  "MaxAttempts": 3,
                  "JitterStrategy": "FULL"
                }
              ]
            },
            "Is individual DataResource?": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Get Data Resource Details",
                  "Condition": "{% $dataResourceId != 'all' %}"
                }
              ],
              "Default": "Get Data Resource Processing State",
              "Output": {
                "uid": "all",
                "lastUpdated": "{% $now() %}"
              }
            },
            "Get Data Resource Details": {
              "Type": "Task",
              "Resource": "arn:aws:states:::http:invoke",
              "Arguments": {
                "ApiEndpoint": "{% $config.collectory_base_url & '/ws/dataResource/' & $dataResourceId %}",
                "Method": "GET",
                "Authentication": {
                  "ConnectionArn": "{% $config.portal_authenticated_connection_arn %}"
                }
              },
              "Retry": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "BackoffRate": 2,
                  "IntervalSeconds": 1,
                  "MaxAttempts": 3,
                  "JitterStrategy": "FULL"
                }
              ],
              "Next": "Get Data Resource Processing State",
              "Output": "{%  $states.result.ResponseBody %}"
            },
            "Get Data Resource Processing State": {
              "Type": "Task",
              "Resource": "arn:aws:states:::dynamodb:getItem",
              "Arguments": {
                "TableName": "{% $config.dynamodb_table_name %}",
                "Key": {
                  "PK": {
                    "S": "{% 'DATA_RESOURCE#' & $dataResourceId %}"
                  },
                  "SK": {
                    "S": "STATE"
                  }
                }
              },
              "Next": "Run Step Function",
              "Output": {
                "dataResource": "{% $states.input %}",
                "dataResourceProcessingState": "{% $exists($states.result.Item) ? $states.result.Item : null %}"
              }
            },
            "Run Step Function": {
              "Type": "Task",
              "Resource": "arn:aws:states:::states:startExecution.sync:2",
              "Arguments": {
                "StateMachineArn": "{% $states.context.Execution.Input.stepArn %}",
                "Input": "{% $merge([$states.context.Execution.Input, {\"AWS_STEP_FUNCTIONS_STARTED_BY_EXECUTION_ID\": $states.context.Execution.Id, \"dataResource\": $states.input.dataResource, \"dataResourceProcessingState\": $states.input.dataResourceProcessingState, \"rootPipelineName\": $states.context.Execution.Input.rootPipelineName}]) %}"
              },
              "End": true
            }
          }
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Next": "Update State and Cleanup Locks",
          "Assign": {
            "newState": "Failed"
          }
        }
      ],
      "Assign": {
        "newState": "{% $exists($states.input.Error) ? 'Failed' : $states.result.Output.result = \"SKIPPED\" ? 'Skipped' : 'Succeeded' %}"
      }
    },
    "Update State and Cleanup Locks": {
      "Type": "Task",
      "Arguments": {
        "TransactItems": [
          {
            "Delete": {
              "TableName": "{% $config.dynamodb_table_name %}",
              "Key": {
                "PK": {
                  "S": "{% 'RUN#' & $states.context.Execution.Input.rootPipelineName %}"
                },
                "SK": {
                  "S": "{% $join(['DATA_RESOURCE', $uppercase($states.context.Execution.Input.stepName), 'RUNNING', $dataResourceId], '#') %}"
                }
              }
            }
          },
          {
            "Put": {
              "TableName": "{% $config.dynamodb_table_name %}",
              "Item": {
                "PK": {
                  "S": "{% 'RUN#' & $states.context.Execution.Input.rootPipelineName %}"
                },
                "SK": {
                  "S": "{% $join(['DATA_RESOURCE', $uppercase($states.context.Execution.Input.stepName), $uppercase($newState), $dataResourceId], '#') %}"
                },
                "DataResourceId": {
                  "S": "{%  $dataResourceId %}"
                },
                "Step": {
                  "S": "{% $uppercase($states.context.Execution.Input.stepName) %}"
                },
                "State": {
                  "S": "{% $uppercase($newState) %}"
                },
                "Timestamp": {
                  "S": "{% $now() %}"
                },
                "ExecutionId": {
                  "S": "{% $states.context.Execution.Id %}"
                },
                "Error": "{% $newState = \"Failed\" ? {\"S\":$states.input.Error} : null %}",
                "Cause": "{% $newState = \"Failed\" ? {\"S\":$states.input.Cause} : null %}"
              }
            }
          },
          {
            "Update": {
              "TableName": "{% $config.dynamodb_table_name %}",
              "Key": {
                "PK": {
                  "S": "{% 'RUN#' & $states.context.Execution.Input.rootPipelineName %}"
                },
                "SK": {
                  "S": "{% 'STATS#' & $uppercase($states.context.Execution.Input.stepName) %}"
                }
              },
              "UpdateExpression": "ADD #newState :one, #running :minusOneIfNotTransactionConflict",
              "ExpressionAttributeNames": {
                "#running": "Running",
                "#newState": "{% $newState %}"
              },
              "ExpressionAttributeValues": {
                ":one": {
                  "N": "1"
                },
                ":minusOneIfNotTransactionConflict": {
                  "N": "{% $exists($states.input.Error) and $states.input.Error = 'DynamoDb.TransactionCanceledException' ? '0' : '-1' %}"
                }
              }
            }
          },
          {
            "Update": {
              "TableName": "{% $config.dynamodb_table_name %}",
              "Key": {
                "PK": {
                  "S": "{% 'LOCK#' & $dataResourceId %}"
                },
                "SK": {
                  "S": "{% 'LOCK#' & $dataResourceId  %}"
                }
              },
              "UpdateExpression": "DELETE #executionIds :executionId",
              "ExpressionAttributeNames": {
                "#executionIds": "ExecutionIds"
              },
              "ExpressionAttributeValues": {
                ":executionId": {
                  "Ss": ["{% $states.context.Execution.Id %}"]
                }
              }
            }
          },
          {
            "Update": {
              "TableName": "{% $config.dynamodb_table_name %}",
              "Key": {
                "PK": {
                  "S": "{% 'LOCK#' & $states.context.Execution.Input.stepName %}"
                },
                "SK": {
                  "S": "{% 'LOCK#' & $states.context.Execution.Input.stepName  %}"
                }
              },
              "UpdateExpression": "DELETE #executionIds :executionId",
              "ExpressionAttributeNames": {
                "#executionIds": "ExecutionIds"
              },
              "ExpressionAttributeValues": {
                ":executionId": {
                  "Ss": ["{% $states.context.Execution.Id %}"]
                }
              }
            }
          }
        ]
      },
      "Resource": "arn:aws:states:::aws-sdk:dynamodb:transactWriteItems",
      "Next": "Should send Unlock",
      "Output": "{% $states.input %}",
      "Retry": [
        {
          "ErrorEquals": ["DynamoDb.TransactionCanceledException"],
          "BackoffRate": 2,
          "IntervalSeconds": 1,
          "MaxAttempts": 3,
          "JitterStrategy": "FULL"
        }
      ]
    },
    "Should send Unlock": {
      "Type": "Choice",
      "Choices": [
        {
          "Next": "Send Unlock Message",
          "Condition": "{% $exists($states.context.Execution.Input.concurrencyLimit) %}"
        }
      ],
      "Default": "Step Result?"
    },
    "Send Unlock Message": {
      "Type": "Task",
      "Resource": "arn:aws:states:::sqs:sendMessage",
      "Arguments": {
        "QueueUrl": "{% $lookup($config.sqs_lock_queues, $lowercase($states.context.Execution.Input.stepName)) %}",
        "MessageBody": {}
      },
      "Next": "Step Result?",
      "Output": "{% $states.input %}"
    },
    "Step Result?": {
      "Type": "Choice",
      "Choices": [
        {
          "Next": "Fail",
          "Condition": "{% $exists($states.input.Error) %}"
        }
      ],
      "Default": "Do Nothing"
    },
    "Do Nothing": {
      "Type": "Pass",
      "Output": {
        "state": "{% $uppercase($newState) %}"
      },
      "End": true
    },
    "Fail": {
      "Type": "Fail",
      "Error": "{% $states.input.Error %}",
      "Cause": "{% $states.input.Cause %}"
    }
  },
  "QueryLanguage": "JSONata"
}
